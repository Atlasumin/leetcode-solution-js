### 396. 旋转函数

难度：Middle

相关话题：`数学`

给定一个长度为 *n*  的整数数组 `A` 。



假设 `Bk` 是数组 `A` 顺时针旋转 *k*  个位置后的数组，我们定义 `A` 的&ldquo;旋转函数&rdquo; `F` 为：



 `F(k) = 0 * Bk[0] + 1 * Bk[1] + ... + (n-1) * Bk[n-1]` 。



计算 `F(0), F(1), ..., F(n-1)` 中的最大值。



**注意:** 
可以认为*n*  的值小于 105。



**示例:** 



```

A = [4, 3, 2, 6]

F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25
F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16
F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23
F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26

所以 F(0), F(1), F(2), F(3) 中的最大值是 F(3) = 26 。
```



-----

思路：

找出每一次旋转的规律，最后一个数的倍数从`len-1`变为`0`，因此要减去`(len-1)*最后一个数`，

然后前面每一个数的倍数都`+1`，因此最后实际增加了整个数组的和`sum`再减去`最后一个数`。

我们只需要找出每一次旋转的最后一个数，因为是循环旋转，最后一个数都是轮流的，因此可以从后向前遍历整个数组，
对每一个数作为最后一个数进行比较。

最后时间复杂度是`O(n)`。

```
/**
 * @param {number[]} A
 * @return {number}
 */
var maxRotateFunction = function(A) {
  let sum=0
  for(let a of A)sum+=a
  
  let curValue=0,n=A.length
  for(let i=0;i<n;i++)curValue+=i*A[i]
  let maxN=curValue
  for(let i=n-1;i>=1;i--){
    curValue-=(n-1)*A[i]
    curValue+=sum-A[i]
    maxN=Math.max(maxN,curValue)
  }
  return maxN
};
```

