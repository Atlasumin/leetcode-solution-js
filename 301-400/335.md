### 335. 路径交叉

难度：Hard

相关话题：`数学`

给定一个含有 `n` 个正数的数组*x* 。从点 `(0,0)` 开始，先向北移动 `x[0]` 米，然后向西移动 `x[1]` 米，向南移动 `x[2]` 米，向东移动 `x[3]` 米，持续移动。也就是说，每次移动后你的方位会发生逆时针变化。



编写一个 `O(1)` 空间复杂度的一趟扫描算法，判断你所经过的路径是否相交。







**示例1:** 



```
┌───┐
│  │
└───┼──>
  │

输入:[2,1,1,2]
输出: true 
```


**示例2:** 



```
┌──────┐
│   │
│
│
└────────────>

输入:[1,2,3,4]
输出:false 
```


**示例 3:** 



```
┌───┐
│  │
└───┼>

输入: [1,1,1,1]
输出: true 
```



-----

思路：

一共就2种绕圈的方法，一种往内绕（越绕越小），一种往外绕（越绕越大），画个图就很简单了。

* 往内绕
     ```
           /|\     
      __1___|_
    |      |
    2      4
    |___3__|
    ```

* 往外绕
    ```
         ___5_
     __1_|__  |
    |    |    |
    |    6    |
    2    |    4
    |   \|/   |
    |___3_____|
    ```

对于往内绕，比较简单，每次只需判断之前的`3条边`，

判断：`4 >= 2 && 3 <= 1`

转换成公式：`aux[i]>=aux[i-2] && aux[i-1]<=aux[i-3]`

对于往外绕，要判断更多的边，

判断：`4 >= 2 && 6 >= 4-2 &&  5 <= 3 && 5 >= 3-1`

转换成公式：`aux[i-2]>=aux[i-4] && aux[i]>=(aux[i-2]-aux[i-4]) &&  aux[i-1]<=aux[i-3] &&  aux[i-1]>=(aux[i-3]-aux[i-5])`


```
/**
 * @param {number[]} x
 * @return {boolean}
 */
var isSelfCrossing = function(x) {
  let aux=x.slice()
  aux.unshift(0)
  for(let i=4;i<aux.length;i++){
    // 往内部绕时交错
    if(aux[i]>=aux[i-2] &amp;&amp; aux[i-1]<=aux[i-3])return true
    // 往外部绕时交错
    if(i>4 &amp;&amp; 
       aux[i-2]>=aux[i-4] &amp;&amp;
       aux[i]>=(aux[i-2]-aux[i-4]) &amp;&amp; 
       aux[i-1]<=aux[i-3] &amp;&amp; 
       aux[i-1]>=(aux[i-3]-aux[i-5])) {
      return true
    }
  }
  return false
};
```

