### 761. 特殊的二进制序列

难度：Hard

相关话题：`递归`、`字符串`

特殊的二进制序列是具有以下两个性质的二进制序列：




* 0 的数量与 1 的数量相等。

* 二进制序列的每一个前缀码中 1 的数量要大于等于 0 的数量。





给定一个特殊的二进制序列 `S` ，以字符串形式表示。定义一个*操作* 为首先选择 `S` 的两个连续且非空的特殊的子串，然后将它们交换。（两个子串为连续的当且仅当第一个子串的最后一个字符恰好为第二个子串的第一个字符的前一个字符。)



在任意次数的操作之后，交换后的字符串按照字典序排列的最大的结果是什么？



**示例 1:** 



```

输入: S = "11011000"
输出: "11100100"
解释:
将子串 "10" （在S[1]出现） 和 "1100" （在S[3]出现）进行交换。
这是在进行若干次操作后按字典序排列最大的结果。
```


**说明:** 




1.  `S` 的长度不超过 `50` 。

2.  `S` 保证为一个满足上述定义的*特殊* 的二进制序列。






-----

思路：

题目给出`特殊二进制字符串`必须是`0`和`1`相等，并且前缀`1`的数量大于`0`的数量。

因此可以定义一个`aux`，当遇到`1`则`++`，遇到`0`则`--`，这么做能方便我们找出`1`和`0`相等的字符串，并且当`aux[i]===0`时，

一定是一个合法的特殊子串。

遍历`aux`，找出所有合法的特殊子串，递归执行这个子串。

最后返回的结果按从大到小排序，并且返回合并值。

```
/**
 * @param {string} S
 * @return {string}
 */
var makeLargestSpecial = function(S) {
  let count=0
  let res=[],k=0
  for(let i=0;i<S.length;i++){
    if(S[i]==="1")count++
    else count--
    if(count===0){
      res.push('1'+makeLargestSpecial(S.substring(k+1,i))+'0')
      k=i+1
    }
  }
  res.sort((a,b)=>{
    if(a<b)return 1
    else return -1
  })
  let ans=''
  for(let s of res)ans+=s
  return ans
};
```

