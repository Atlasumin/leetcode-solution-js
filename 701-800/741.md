### 741. 摘樱桃

难度：Hard

相关话题：`动态规划`

一个N x N的网格 `(grid)` 代表了一块樱桃地，每个格子由以下三种数字的一种来表示：




* 0 表示这个格子是空的，所以你可以穿过它。

* 1 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。

* -1 表示这个格子里有荆棘，挡着你的路。





你的任务是在遵守下列规则的情况下，尽可能的摘到最多樱桃：




* 从位置(0, 0) 出发，最后到达 (N-1, N-1) ，只能向下或向右走，并且只能穿越有效的格子（即只可以穿过值为0或者1的格子）；

* 当到达 (N-1, N-1) 后，你要继续走，直到返回到 (0, 0) ，只能向上或向左走，并且只能穿越有效的格子；

* 当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为0）；

* 如果在 (0, 0) 和 (N-1, N-1) 之间不存在一条可经过的路径，则没有任何一个樱桃能被摘到。





**示例 1:** 



```

输入: grid =
[[0, 1, -1],
 [1, 0, -1],
 [1, 1,  1]]
输出: 5
解释： 
玩家从（0,0）点出发，经过了向下走，向下走，向右走，向右走，到达了点(2, 2)。
在这趟单程中，总共摘到了4颗樱桃，矩阵变成了[[0,1,-1],[0,0,-1],[0,0,0]]。
接着，这名玩家向左走，向上走，向上走，向左走，返回了起始点，又摘到了1颗樱桃。
在旅程中，总共摘到了5颗樱桃，这是可以摘到的最大值了。
```


**说明:** 




* `grid`  是一个 `N`  *  `N`  的二维数组，N的取值范围是 `1 <= N <= 50` 。

* 每一个 `grid[i][j]`  都是集合 `{-1, 0, 1}` 其中的一个数。

* 可以保证起点 `grid[0][0]` 和终点 `grid[N-1][N-1]` 的值都不会是 -1。






-----

思路：

这道题初一看有点像`路径最大和`问题，但细想不能这么做，因为走完第一次，摘取的樱桃会消失，
因此子问题互相有影响。

 思路：
 1. 走2次，由于走完第一次，摘取的樱桃会消失，因此不能使用单程DP*2，因为子问题互相有影响。
 2. 可以看成是2个人一起从左上走到右下，或者从右下走到左上。
 3. 由于2个人是同步行走，因此任何一方超出规则，都视为无效路径。
 4. 当他们走到同一格，只能摘取1个樱桃。
 5. 使用mem记录他们走过的格子不必重复计算，复杂度从指数降到3次方

```
/**
 * @param {number[][]} grid
 * @return {number}
 */
var cherryPickup = function(grid) {
  // 思路：
  // 1. 走2次，由于走完第一次，摘取的樱桃会消失，因此不能使用单程DP*2，因为子问题互相有影响。
  // 2. 可以看成是2个人一起从左上走到右下，或者从右下走到左上。
  // 3. 由于2个人是同步行走，因此任何一方超出规则，都视为无效路径。
  // 4. 当他们走到同一格，只能摘取1个樱桃。
  // 5. 使用mem记录他们走过的格子不必重复计算，复杂度从指数降到3次方
  let n=grid.length
  let mem=[]
  // 创建mem，记录x1,y1和x2,y2的行走记录
  for(let i=0;i<n;i++){
    mem[i]=[]
    for(let j=0;j<n;j++){
      mem[i][j]=[]
      for(let k=0;k<n;k++){
        mem[i][j][k]=-Infinity
      }
    }
  }
  return Math.max(0,dp(n-1,n-1,n-1))
  // 返回从x1,y1 和 从x2,y2一起走到 0,0能最多摘到樱桃数
  function dp(x1,y1,x2){
    let y2=x1+y1-x2
    // 任意一个超出边界 返回
    if(x1<0||x2<0||y1<0||y2<0)return -1
    // 任意一个进入荆棘，返回
    if(grid[x1][y1]<0 || grid[x2][y2]<0)return -1
    // 到达终点，返回
    if(x1===0 && y1===0)return grid[x1][y1]
    // 存在记录，直接返回记录
    if(mem[x1][y1][x2]!==-Infinity)return mem[x1][y1][x2]
    // 子问题，分别计算x1,y1 和 x2,y2的所有能走的情况(4种)
    let res=Math.max(dp(x1-1,y1,x2-1),dp(x1-1,y1,x2),dp(x1,y1-1,x2-1),dp(x1,y1-1,x2))
    // 子问题无解，返回并且记录-1
    if(res<0)return mem[x1][y1][x2]=-1
    // 获取x1,y1摘得樱桃数
    res+=grid[x1][y1]
    // 如果x1,y1和x2,y2不在同一个位置，加上x2,y2摘的樱桃数
    if(x1!==x2 && y1!==y2)res+=grid[x2][y2]
    // 记录
    mem[x1][y1][x2]=res
    return res
  }
};
```

