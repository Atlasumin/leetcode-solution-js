### 775. 全局倒置与局部倒置

难度：Middle

相关话题：`数组`、`数学`

数组 `A` 是 `[0, 1, ..., N - 1]` 的一种排列， `N`  是数组 `A` 的长度。全局倒置指的是  `i,j` 满足 `0 <= i < j < N`  并且 `A[i] > A[j]` ，局部倒置指的是  `i`  满足 `0 <= i < N` 并且 `A[i] > A[i+1]` 。



当数组 `A` 中全局倒置的数量等于局部倒置的数量时，返回  `true`  。







**示例 1:** 



```

输入: A = [1,0,2]
输出: true
解释: 有 1 个全局倒置，和 1 个局部倒置。
```


**示例 2:** 



```

输入: A = [1,2,0]
输出: false
解释: 有 2 个全局倒置，和 1 个局部倒置。
```


**注意:** 




* `A`  是 `[0, 1, ..., A.length - 1]` 的一种排列

* `A`  的长度在 `[1, 5000]` 之间

* 这个问题的时间限制已经减少了。






-----

思路：

1. 最初看到问题的想法是将全局倒置数量和局部倒置数量都计算出来，最后对比，但是`TLE`了，这么做时间复杂度是`O(N^2)`。

2. 其实仔细一思考，一旦发现存在全局倒置，就可以立刻返回`false`了，因此有局部倒置必然有全局倒置，而有全局倒置不一定有局部倒置。

3. 遍历的时候将遍历过的最大值保存，一旦发现当前值小于这个最大值，说明存在额外的全局倒置，最终时间复杂度是`O(N)`。

```
/**
 * @param {number[]} A
 * @return {boolean}
 */
var isIdealPermutation = function(A) {
        let cmax = 0;
        for (let i = 0; i < A.length - 2; ++i) {
            cmax = Math.max(cmax, A[i]);
            // 当符合这个条件，global能获取，local 必定不能获取，因为中间隔了一个位置
            if (cmax > A[i + 2]) return false;
        }
        return true;
};
```

