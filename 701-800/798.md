### 798. 得分最高的最小轮调

难度：Hard

相关话题：

给定一个数组 `A` ，我们可以将它按一个非负整数  `K` 进行轮调，这样可以使数组变为 `A[K], A[K+1], A{K+2], ... A[A.length - 1], A[0], A[1], ..., A[K-1]` 的形式。此后，任何值小于或等于其索引的项都可以记作一分。



例如，如果数组为 `[2, 4, 1, 3, 0]` ，我们按 `K = 2` 进行轮调后，它将变成 `[1, 3, 0, 2, 4]` 。这将记作 3 分，因为 1 > 0 [no points], 3 > 1 [no points], 0 <= 2 [one point], 2 <= 3 [one point], 4 <= 4 [one point]。



在所有可能的轮调中，返回我们所能得到的最高分数对应的轮调索引 K。如果有多个答案，返回满足条件的最小的索引 K。





```
示例 1：


输入：

[2, 3, 1, 4, 0]
输出：

3
解释：


下面列出了每个 K 的得分：
K = 0,  A = [2,3,1,4,0],    score 2
K = 1,  A = [3,1,4,0,2],    score 3
K = 2,  A = [1,4,0,2,3],    score 3
K = 3,  A = [4,0,2,3,1],    score 4
K = 4,  A = [0,2,3,1,4],    score 3
所以我们应当选择K = 3，得分最高。
```








```
示例 2：


输入：

[1, 3, 0, 2, 4]
输出：

0
解释：


A 无论怎么变化总是有 3 分。
所以我们将选择最小的 K，即 0。

```


**提示：** 




* `A` 的长度最大为 `20000` 。

* `A[i]`  的取值范围是 `[0, A.length]` 。






-----

思路：

对于某一个`i`和`A[i]`，它能提供的分数的`K`的范围一定一个连续区间(可能是首尾相连)；

例如：`N=5`，`i=0`，`A[i]=2`

当`K`为`0`，`i`为0，`i-A[i]===-2`，不符合；

当`K`为`1`，`i`为4，`i-A[i]===2`，符合；

当`K`为`2`，`i`为3，`i-A[i]===1`，符合；

当`K`为`3`，`i`为2，`i-A[i]===0`，符合；

当`K`为`4`，`i`为1，`i-A[i]===-1`，不符合；

`K`在`[1,3]`这一段连续区间是能提供分数的，对于以上数据，可以通过：

`left=(i - A[i] + n + 1) % n`

`right = (i + 1) % n`

计算出`left`为`4`，`right`为`1`，也就是说，从`K===4`开始一直到`K===1`之前都是不计分的。

对于这个结果，使用一个数组`bad`专门记录这个区间，可以这么表示`bad[4]--`，`bad[0]--`，如果这么表示，那么时间复杂度又回到`O(N^2)`。

因此使用一个非常精妙的连续区间表示方法：`bad[left]++`，`bad[right]--`并且如果`left>right`，说明首尾相连，需要`bad[0]--`；

当我们后续计算的时候，通过`bad`的前缀和计算，

例如现在：`bad=[-1,1,0,0,-1]`，它的前缀和数组为`sum=[-1,0,0,0,-1]`，可以很清楚地看到，除了`0`和`4`的位置，其他都是能得分的位置。




```
/**
 * @param {number[]} A
 * @return {number}
 */
var bestRotation = function(A) {
  const n = A.length;
  if (n === 0) {
    return 0;
  }
  
  const bad = Array(n).fill(0);
  
  for(let i = 0; i < n; i++) {
    const left = (i - A[i] + n + 1) % n;
    const right = (i + 1) % n;
    bad[left]--;
    bad[right]++;
    if (left > right) {
      bad[0]--;
    }
  }
  let best = -n;
  let ans = 0, cur = 0;
  for(let i = 0; i < n; i++) {
    cur += bad[i]
    if (cur > best) {
      best = cur;
      ans = i;
    }
  }
  
  return ans;
};



```

