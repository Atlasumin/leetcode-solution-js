### 927. 三等分

难度：Hard

相关话题：`贪心算法`、`数学`、`二分查找`

给定一个由  `0`  和  `1`  组成的数组 `A` ，将数组分成 3个非空的部分，使得所有这些部分表示相同的二进制值。



如果可以做到，请返回 **任何**  `[i, j]` ，其中  `i+1 &lt; j` ，这样一来：





*  `A[0], A[1], ..., A[i]` 组成第一部分；

*  `A[i+1], A[i+2], ..., A[j-1]` 作为第二部分；

*  `A[j], A[j+1], ..., A[A.length - 1]`  是第三部分。

* 这三个部分所表示的二进制值相等。





如果无法做到，就返回 `[-1, -1]` 。



注意，在考虑每个部分所表示的二进制时，应当将其看作一个整体。例如， `[1,1,0]` 表示十进制中的 `6` ，而不会是 `3` 。此外，前导零也是被允许的，所以 `[0,1,1]`  和 `[1,1]` 表示相同的值。







 **示例 1：** 





```
输入：

[1,0,1,0,1]
输出：

[0,3]

```

 **示例 2：** 





```
输出：

[1,1,0,1,1]
输出：

[-1,-1]
```





 **提示：** 





1.  `3 &lt;= A.length &lt;= 30000` 

2.  `A[i] == 0` 或 `A[i] == 1` 










-----

思路：

这道题我最初思路是`window slide`，通过设定2个指针，`left`和`right`，每次移动判断当前应该`left`增减还是`right`增加。

结果是`TLE`，给定的数组范围是`[3,30000]`，这道题是存在`O(N)`的解，充分利用只存在`0`和`1`这一特性。

思路：所有的`0`作为每一个字符串的开头，相当于没有
1. 因为可能存在`[0,0,1,0]`与`[1,0]`相等的情况，因此对于`0`，首先不去处理，只记录`1`的数量和1的位置。
2. 对于所有的`1`，将数组分割成3段具有相同`1`的数量的，如果无法分割，则无解。
3. 对于`[1,0,1,0,1,0]`这种情况，我们分割了`1`，接着处理每一段`1`**后面**的`0`，前面的不需要处理。
4. 对于第一段和第二段，它们后面的`0`，可以超过第三段，但不能少于第三段，这是因为如果第一段后的`0`更多，
可以让它接在第二段开头，如果第二段后面`0`更多，可以让它接在第三段开头，但是如果第三段后面的`0`更多，再没有能给它接的。


```
/**
 * @param {number[]} A
 * @return {number[]}
 */
var threeEqualParts = function(A) {
  // 思路：只处理1开头和1结尾的字符串，所有的0作为每一个字符串的开头，相当于没有
  let IMP = [-1, -1];
  let N = A.length;

  let S = 0;
  for (let x of A) S += x;
  // 1的数量不是3的倍数，返回impossible
  if (S % 3 != 0) return IMP;
  let T = S / 3;
  // 不存在1，返回impossible
  if (T == 0)
      return [0, N - 1];

  // 通过上面确定了，每一个字符串中的1的数量必须为T
  // 当发现1开头，给第一个字符串，当到T时，第一个字符串结尾
  // T+1时，给第二个字符串....
  let i1 = -1, j1 = -1, i2 = -1, j2 = -1, i3 = -1, j3 = -1;
  let su = 0;
  for (let i = 0; i &lt; N; ++i) {
      if (A[i] == 1) {
          su += 1;
          if (su == 1) i1 = i;
          if (su == T) j1 = i;
          if (su == T+1) i2 = i;
          if (su == 2*T) j2 = i;
          if (su == 2*T + 1) i3 = i;
          if (su == 3*T) j3 = i;
      }
  }


  let part1 = A.slice(i1,j1+1)
  let part2 = A.slice(i2,j2+1)
  let part3 = A.slice(i3,j3+1)

  // 检测这3个数组如果不相等，返回impossible
  for(let i=0;i&lt;part1.length;i++){
    if(part1[i]!==part2[i] || part1[i]!==part3[i])return IMP
  }

  let x = i2 - j1 - 1;
  let y = i3 - j2 - 1;
  let z = A.length - j3 - 1;

  if (x &lt; z || y &lt; z) return IMP;
  return [j1+z, j2+z+1];
};



```
