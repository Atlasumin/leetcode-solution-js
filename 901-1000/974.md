### 974. 和可被 K 整除的子数组

难度：Middle

相关话题：`数组`、`哈希表`

给定一个整数数组  `A` ，返回其中元素之和可被  `K` 整除的（连续、非空）子数组的数目。







**示例：** 



```
输入：A = [4,5,0,-2,-3,1], K = 5
输出：7
解释：有 7 个子数组满足其元素之和可被 K = 5 整除：
[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]
```






**提示：** 




1.  `1 <= A.length <= 30000` 

2.  `-10000 <= A[i] <= 10000` 

3.  `2 <= K <= 10000` 






-----

思路：

被整除也就是用`%`处理，我们需要保存每一次的`%`，因为如果当前算出的模，在`hash`中已经存在，那么说明已经找到了能被K整除的子数组。

例如`a % K =4 && (a+b+c) % K =4`条件成立，那么可以确保`b,c`这个子数组是能被`K`整除的子数组。

但是，还需要额外考虑一个因素，那就是负数，如果不对负数的模进行处理，当同时出现正负数，会错过一些正确的值。

例如考虑`[4,-2,-3]` `K`为5,，如果我们按照上面的办法，那么当计算到`index为2(值为-3)`的时候，`hash`为`{4:1, 2:1}`，
这时的`sum`是`4+ -2`，现在再加`-3`，sum为`-1`，模为`-1 % 5 =-1`，我们发现，hash中并没有模为 `-1`的值，但其实`-1`是一个
需要收集的答案，因为`-2 + -3`能被`5`整除。

因此当`sum`为负数时，我们需要转换为正数，再去从`hash`中获取。

```
/**
 * @param {number[]} A
 * @param {number} K
 * @return {number}
 */
var subarraysDivByK = function(A, K) {
  let hash={},sum=0,res=0
  hash[0]=1
  for(let i=0;i<A.length;i++){
    sum+=A[i]
    let m=(sum % K + K) % K
    if(hash[m]==null)hash[m]=1
    else{
      res+=hash[m]
      hash[m]++   
    }
  }
  return res
};
```

