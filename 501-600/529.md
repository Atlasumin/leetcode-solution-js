### 529. 扫雷游戏

难度：Middle

相关话题：`深度优先搜索`、`广度优先搜索`

让我们一起来玩扫雷游戏！

给定一个代表游戏板的二维字符矩阵。**&#39;M&#39;** 代表一个**未挖出的** 地雷，**&#39;E&#39;** 代表一个**未挖出的** 空方块，**&#39;B&#39;** 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的**已挖出的** 空白方块，**数字** （&#39;1&#39; 到 &#39;8&#39;）表示有多少地雷与这块**已挖出的** 方块相邻，**&#39;X&#39;** 则表示一个**已挖出的** 地雷。

现在给出在所有**未挖出的** 方块中（&#39;M&#39;或者&#39;E&#39;）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：

1. 如果一个地雷（&#39;M&#39;）被挖出，游戏就结束了- 把它改为**&#39;X&#39;** 。
2. 如果一个**没有相邻地雷** 的空方块（&#39;E&#39;）被挖出，修改它为（&#39;B&#39;），并且所有和其相邻的方块都应该被递归地揭露。
3. 如果一个**至少与一个地雷相邻** 的空方块（&#39;E&#39;）被挖出，修改它为数字（&#39;1&#39;到&#39;8&#39;），表示相邻地雷的数量。
4. 如果在此次点击中，若无更多方块可被揭露，则返回面板。




**示例 1：** 



```
输入:

 [[&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;], [&#39;E&#39;, &#39;E&#39;, &#39;M&#39;, &#39;E&#39;, &#39;E&#39;], [&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;], [&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;]]Click : [3,0]输出:

 [[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;], [&#39;B&#39;, &#39;1&#39;, &#39;M&#39;, &#39;1&#39;, &#39;B&#39;], [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;], [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]解释:

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/minesweeper_example_1.png)

```
**示例 2：** 



```
输入:

 [[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;], [&#39;B&#39;, &#39;1&#39;, &#39;M&#39;, &#39;1&#39;, &#39;B&#39;], [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;], [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]Click : [1,2]输出:

 [[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;], [&#39;B&#39;, &#39;1&#39;, &#39;X&#39;, &#39;1&#39;, &#39;B&#39;], [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;], [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]解释:

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/minesweeper_example_2.png)

```


**注意：** 

1. 输入矩阵的宽和高的范围为 [1,50]。
2. 点击的位置只能是未被挖出的方块 (&#39;M&#39; 或者 &#39;E&#39;)，这也意味着面板至少包含一个可点击的方块。
3. 输入面板不会是游戏结束的状态（即有地雷已被挖出）。
4. 简单起见，未提及的规则在这个问题中可被忽略。例如，当游戏结束时你不需要挖出所有地雷，考虑所有你可能赢得游戏或标记方块的情况。




-----

思路：

如果`click`的点是`M`，变为`X`，结束

如果`click`的点是`E`，`dfs`

* 找出当前点是否数字点(通过周围是否有雷来判断)，是数字电直接显示数字；

* 如果不是数字点，那么就递归周边所有的点。

如果`click`的点是其他，直接返回即可。


```
/**
 * @param {character[][]} board
 * @param {number[]} click
 * @return {character[][]}
 */
var updateBoard = function(board, click) {
  let m=board.length,n=board[0].length
  function reveal(board,i,j){
    if(board[i][j]==="M")board[i][j]="X"
    else if(board[i][j]==="E"){
      checkAdj(board,i,j)
    }
  }
    
  function checkAdj(b,i,j){
    let mine=0
    for(let x=-1;x<=1;x++){
      for(let y=-1;y<=1;y++){
        if(x===0 &amp;&amp; y===0)continue
        let nx=x+i,ny=y+j
        if(nx<0 || ny<0 || nx>=m || ny>=n)continue
        if(b[nx][ny]==="M")mine++
      }
    }
    if(mine>0){
      b[i][j]=mine+''
    }else{
      b[i][j]='B'
      for(let x=-1;x<=1;x++){
        for(let y=-1;y<=1;y++){
          if(x===0 &amp;&amp; y===0)continue
          let nx=x+i,ny=y+j
          if(nx<0 || ny<0 || nx>=m || ny>=n)continue
          reveal(b,nx,ny)
        }
      }
    }
  }
  reveal(board,click[0],click[1])
  return board
};



```

