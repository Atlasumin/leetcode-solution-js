### 440. 字典序的第K小数字

难度：Hard

相关话题：

给定整数 `n` 和 `k` ，找到 `1` 到 `n` 中字典序第 `k` 小的数字。



注意：1 &le; k &le; n &le; 109。



 **示例 :** 





```

输入:


n: 13   k: 2

输出:


10

解释:


字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。

```


-----

思路：

每次计算一段的数量，从`1`开始，计算`1`到`2`之前的有效的数的数量，有效数指不大于`n`的数，例如如果`n`为`2100`，
那么`1`到`2`的有效数就是`1111`个；如果`n`为`1457`，那么`1`到`2`的有效数就是`569`个。

如果防线当前段的有效数个数`step`超过了`k`，说明结果就在这一段中，需要在当前段进一步检查，例如，原来是`7`到`8`，那么进一步则`70`到`71`；

例如：`n=1457`，`k=1234`

第一段的检查如下：
```
初始k:1234-1

当前间隔step：   569,  111,  111,  111,  111,  111,  111
剩余k：          664,  553,  442,  331,  220.  109,  -2(结果这就在7-8之间)
               1 --- 2 --- 3 --- 4 --- 5 --- 6 --- 7 --- 8
               10 -- 20 -- 30 -- 40 -- 50 -- 60 -- 70 -- 80
               100 - 200 - 300 - 400 - 500 - 600 - 700 - 800
               1000-1457   
```

上面当检查到剩余`k`不足时，说明结果就在`7`和`8`之间。


```
/**
 * @param {number} n
 * @param {number} k
 * @return {number}
 */
var findKthNumber = function(n, k) {
  let cur=1
  k-=1
  while(k&gt;0){
    let step=calcStep(n,cur,cur+1)
    if(step&lt;=k){
      k-=step
      cur++
    }else if(step&gt;k){
      k--
      cur*=10
    }
  }
  return cur
  // 分别计算 1和2之间的数，2和3之间的数....10和11之间的数....100和101之间的数...
  function calcStep(n,cur,next){
    let count=0
    // 当cur&lt;=n的时候，cur和next之间的数量总是10的指数
    while(cur&lt;=n){
      count+=Math.min(n+1,next)-cur
      cur*=10
      next*=10
    }
    return count
  }
};



```
