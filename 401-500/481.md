### 481. 神奇字符串

难度：Middle

相关话题：

神奇的字符串**S** 只包含 &#39;1&#39; 和 &#39;2&#39;，并遵守以下规则：



字符串 **S**  是神奇的，因为串联字符 &#39;1&#39; 和 &#39;2&#39; 的连续出现次数会生成字符串 **S**  本身。



字符串**S** 的前几个元素如下：**S** = &ldquo;1221121221221121122 ......&rdquo;



如果我们将**S**  中连续的 1 和 2 进行分组，它将变成：



1 22 11 2 1 22 1 22 11 2 11 22 ......



并且每个组中 &#39;1&#39; 或 &#39;2&#39; 的出现次数分别是：



1 2 2 1 1 2 1 2 2 1 2 2 ......



你可以看到上面的出现次数就是 **S**  本身。



给定一个整数 N 作为输入，返回神奇字符串 **S** 中前 N 个数字中的 &#39;1&#39; 的数目。



**注意：** N 不会超过 100,000。



**示例：** 



```
输入：

6
输出：

3
解释：

神奇字符串 S 的前 6 个元素是 &ldquo;12211&rdquo;，它包含三个 1，因此返回 3。
```







-----

思路：

由于`N`最大为`100000`，完全可以模拟整个字符串，相当于是暴力解吧。

题目已经给出了一部分神奇数字`S=1221121221221121122`，它的频率是`freqS=122112122122`，下一个数字`nxt=1`，那么接下来该怎么计算？

接下来需要找出`freqS`还可以延长的部分，也就是当前`S`与`freqS`相差的那一部分，即`1121122`，作为接下来的频率，继续延长`S`，直到`S.length>=n`。

```
/**
 * @param {number} n
 * @return {number}
 */
var magicalString = function(n) {
  let count2=0,nxt='1'
  let S='1221121221221121122',
     freqS='122112122122'
  while(S.length<n){
   let nxtFreq=S.substring(freqS.length)
   freqS+=nxtFreq
   let i=0
   while(i<nxtFreq.length &amp;&amp; S.length<n){
     S+=nxt.repeat(nxtFreq[i++])
     nxt=nxt==="1"?"2":"1"
   }
  }
  let res=0
  for(let i=0;i<n;i++){
    if(S[i]==='1')res++
  }
  return res
};
```

