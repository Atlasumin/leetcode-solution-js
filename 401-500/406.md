### 406. 根据身高重建队列

难度：Middle

相关话题：`贪心算法`

假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对 `(h, k)` 表示，其中 `h` 是这个人的身高， `k` 是排在这个人前面且身高大于或等于 `h` 的人数。 编写一个算法来重建这个队列。



**注意：** 
总人数少于1100人。



**示例** 



```

输入:
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

输出:
[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
```



-----

思路：

一个笨办法就是，先对`people`排序，按先索引`0`升序，如果相等则索引`1`升序的排序。

每次遍历`people`，现将当前`people[i]`插入到`res`最后面，然后搜索前面有多少比它高的值`larger`，如果`larger>people[i][1]`，
说明不符合要求，前面高的人多了，通过不断和前一个`swap`，直到`larger===people[i][1]`。

这里的可以将搜索优化，建立一个升序数组，使用二分搜索。

另外一个非常精妙的解决办法，同样先对`people`排序，按索引`0`降序，如果相等则索引`1`升序的排序。

按照身高降序，保证了不可能将高的插入到矮的前面的位置，而只可能将矮的插入到高的前面的位置，这么就不会影响已经排好序的高的位置。

排序好后，对每一个`people[i]`，使用`splice`插入它对应的`people[i][1]`的位置。

```
/**
 * @param {number[][]} people
 * @return {number[][]}
 */
var reconstructQueue = function(people) {
  let res=[];
  people.sort((a,b)=>a[0]===b[0] ? a[1]-b[1] : b[0]-a[0])
  for(let i=0;i<people.length;i++){
    res.splice(people[i][1],0,people[i])
  }
  return res
};
```

