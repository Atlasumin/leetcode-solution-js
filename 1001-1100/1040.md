### 1040. 移动石子直到连续 II

难度：Middle

相关话题：`数组`、`Sliding Window`

在一个长度**无限** 的数轴上，第  `i`  颗石子的位置为 `stones[i]` 。如果一颗石子的位置最小/最大，那么该石子被称作**端点石子** 。



每个回合，你可以将一颗端点石子拿起并移动到一个未占用的位置，使得该石子不再是一颗端点石子。



值得注意的是，如果石子像 `stones = [1,2,5]` 这样，你将**无法** 移动位于位置 5 的端点石子，因为无论将它移动到任何位置（例如 0 或 3），该石子都仍然会是端点石子。



当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。



要使游戏结束，你可以执行的最小和最大移动次数分别是多少？ 以长度为 2 的数组形式返回答案： `answer = [minimum_moves, maximum_moves]`  。







**示例 1：** 



```
输入：[7,4,9]
输出：[1,2]
解释：
我们可以移动一次，4 -> 8，游戏结束。
或者，我们可以移动两次 9 -> 5，4 -> 6，游戏结束。
```


**示例2：** 



```
输入：[6,5,4,3,10]
输出：[2,3]
解释：
我们可以移动 3 -> 8，接着是 10 -> 7，游戏结束。
或者，我们可以移动 3 -> 7, 4 -> 8, 5 -> 9，游戏结束。
注意，我们无法进行 10 -> 2 这样的移动来结束游戏，因为这是不合要求的移动。
```


**示例 3：** 



```
输入：[100,101,104,102,103]
输出：[0,0]
```






**提示：** 




1.  `3 <= stones.length <= 10^4` 

2.  `1 <= stones[i] <= 10^9` 

3.  `stones[i]` 的值各不相同。










-----

思路：

首先对`stones`升序排序。

**求最大值**：

每次可以移动最左端或者最右端，因此最大值一定是要么第一次移动的是最左端，要么第一次移动的是最右端；

如果第一次移动最右端，那么第一步一定是移到最右边开始第二个的前面，即`stones[n-2]`，`n`为`stones`的长度，并且最左的位置是`stones[0]`，
因此移动距离就是`stones[n-2]-stones[0]-1-(n-3)`，也就是当前区间内部的位置，减去内部已经有石头的数量(有`3`个不在区间内部，分别是区间左右端2个和最后1个`stones[n-1]`)，剩下的空位置就是能移动石头的位置。

例如：`[1,3,5,7,12,65]`，`1`到`12`之间还剩下7个空位置，也就是先移动右端，能最多移动7次。

同样的，如果第一次移动最左端，那么第一步一定是移动到最左边开始第二个的后面，即`stones[1]`，它的最右端即是`stones[n-1]`，
因此移动距离就是`stones[n-1]-stones[1]-1-(n-3)`；

例如：`[1,3,5,7,12,65]`，`3`到`65`之间还剩下58个空位置，也就是先移动左端，能最多移动58次。

上面两个值取最大值就是当前能移动的最大步数。

**求最小值**：

`window slide`，不断构造一个区间，这个区间`[i,j]`满足，区间的长度不会大于石头的数量，即这个区间是可以被区间外部的石头塞满的(可以塞不下，但不能有空隙)。

接着检查如果这个区间是**连续**的并且外部非连续的只有**1**个，那么这是一种特殊情况，返回`2`。

例如`[1,2,3,4,10]`，区间`[1,2,3,4]`是连续的，但外部非连续的只有1个，需要将`1`放到`6`的位置，再将`10`放到`5`的位置。

如果不是以上的特殊情况，那么不需要检查区间内部是否连续了，也就是将除了`[i,j]`区间以外的数字放入`[i,j]`区间，放不下的要让它们连续，只需要`n-(j-i+1)`步。

例如：

区间内部不连续：

`[1,4,7,9,20,30]`，当前`i`为0，`j`为1，那么将`[7,9,20,30]`与`[1,4]`连续只需要4步

1. 将`30`放入`6`的位置，`[1,4,6,7,9,20]`；
2. 将`20`放入`5`的位置，`[1,4,5,6,7,9]`；
3. 将`9`放入`3`的位置，`[1,3,4,5,6,7]`；
4. 将`7`放入`2`的位置，`[1,2,3,4,5,6]`，结束。

区间内部连续：

`[1,2,3,56,89]`，`i`为0，`j`为2，只需要2步

1. 将`89`放入`5`的位置，`[1,2,3,5,56]`；
2. 将`56`放入`4`的位置，`[1,2,3,4,5]`，结束。

```
/**
 * @param {number[]} stones
 * @return {number[]}
 */
var numMovesStonesII = function(stones) {
  stones.sort((a,b)=>a-b)
  let n=stones.length
  let max=Math.max(stones[n-1]-stones[1]-1-(n-3),stones[n-2]-stones[0]-1-(n-3))
  let min=Infinity

  let i=0
  for(let j=0;j<n;j++){
    while(stones[j]-stones[i]-1>n-2)i++
    if (j-i+1===n-1 && stones[j]-stones[i]===n-2){
      min=Math.min(min,2)
    }else{
      min=Math.min(min,n-(j-i+1))
    }
  }
  return [min,max]
};
```

