### 1049. 最后一块石头的重量 II

难度：Middle

相关话题：

有一堆石头，每块石头的重量都是正整数。



每一回合，从中选出**任意两块石头** ，然后将它们一起粉碎。假设石头的重量分别为 `x`  和 `y` ，且 `x <= y` 。那么粉碎的可能结果如下：




* 如果 `x == y` ，那么两块石头都会被完全粉碎；

* 如果 `x != y` ，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x` 。





最后，最多只会剩下一块石头。返回此石头**最小的可能重量** 。如果没有石头剩下，就返回  `0` 。







**示例：** 



```
输入：[2,7,4,1,8,1]
输出：1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。
```






**提示：** 




1.  `1 <= stones.length <= 30` 

2.  `1 <= stones[i] <= 1000` 






-----

思路：

目的就是将这个`stones`数组分割成2堆，使得这两堆的差最小，为什么可以这么分？

例如有几个数`a,b,c,d,e`，根据题目意思，两个石头互相减去重量，即其中2种分法为(假设都保证是大数减小数)：

`(a-b)-(c-d)-e` ===>`a-b-c+d-e`===>`(a+d)-(b+c+e)`
`((a-b)-c)-(d-e)` ===>`a-b-c-d+e`===>`(a+e)-(b+c+d)`

可以看出，最后的结果相当于用一部分数字的和减去另一部分数字的和，也就是分成两堆的差。

因此要求出两堆的最小差，只需要先确定一部分的和`s`，那么另一个部分的和为`sum-s`。

使用`DP`，`dp[i]`表示`i`这个数是否是当前数组的某几个数字组成的和，例如`[1,2,5]`，那么能组成的和为`1,2,3,5,6,7,8`；

最后对`dp[i]`存在的数，算出两堆的差`i-(sum-i)`，取最小值。

```
/**
 * @param {number[]} stones
 * @return {number}
 */
var lastStoneWeightII = function(stones) {
  let sum=stones.reduce((a,b)=>a+b)
  let dp=Array(sum+1).fill(0)
  dp[0]=1
  for(let i=0;i<stones.length;i++){
    let cur=stones[i]
    for(let j=dp.length-1;j>=cur;j--){
      if(dp[j-cur]){
        dp[j]=1
      }
    }
  }
  let minLen=Infinity
  for(let i=0;i<dp.length;i++){
    if(dp[i]){
      if(i*2-sum>=0)minLen=Math.min(minLen,i*2-sum)
    }
  }
  return minLen
};
```

