### 862. 和至少为 K 的最短子数组

难度：Hard

相关话题：`队列`、`二分查找`

返回  `A`  的最短的非空连续子数组的**长度** ，该子数组的和至少为  `K`  。



如果没有和至少为 `K` 的非空子数组，返回 `-1` 。












**示例 1：** 



```
输入：A = [1], K = 1
输出：1
```


**示例 2：** 



```
输入：A = [1,2], K = 4
输出：-1
```


**示例 3：** 



```
输入：A = [2,-1,2], K = 3
输出：3
```






**提示：** 




1.  `1 <= A.length <= 50000` 

2.  `-10 ^ 5<= A[i] <= 10 ^ 5` 

3.  `1 <= K <= 10 ^ 9` 






-----

思路：

刚开始处理这个问题，我使用的是处理和为`K`的子数组的方法，再通过一个`window slide`不断处理内部的值，当其大于等于`K`的时候，
记录一下`slide`的长度。

但这个方法的问题就是一旦需要的子数组在`slide`中间，则无法获取

例如：
```
A=[-34,37,51,3,-12,-50,51,100,-47,99,34]
K=151
```

用上面的办法结果是`4`，会卡在`[51,100,-47,99]`这样的子数组中，接着是`[100,-47,99]`，无法算出`51,100`这个子数组。

正确应该是`2`。

正确思路：
1. 第一步相同，需要算出当前数与之前的和的数组。
2. 定义一个数组`d`，存放可以作为子数组开始的点。
3. `d`中的值遇到以下2种情况，可以删除。
    1. 遇到某个点`i`与`d[0]`之间的和已经`>=K`了，说明`d[0]`这个点是有效的，需要记录长度，并且删除(尝试右移)。
    2. 遇到某个点`i`加上它后，当前和比`d[d.length-1]`这个点的和更小或者相等，说明这个`i`是负值或者0，
    说明这个`d[d.length-1]`点是无效的，是不能做为子数组开始的点，需要删除。
    

```
/**
 * @param {number[]} A
 * @param {number} K
 * @return {number}
 */
var shortestSubarray = function(A, K) {
    let N = A.length
    let sum = Array(N+1).fill(0)
    // 算和
    for(let i=0;i<N;i++){
      sum[i+1]=sum[i]+A[i]
    }
    // d存放从哪个点开始计算和
    let d=[]
    let res=N+1
    
    for(let i=0;i<N+1;i++){
      // 如果当前点(i)的和 >= d的第一个点的和
      // 说明在d[0]和i之间这一段数字的和 >= K
      // 需要算出这一段距离，并且可以删除d的第一个点
      // 循环检查
      while(d.length>0 &amp;&amp; sum[i]-sum[d[0]]>=K){
        res=Math.min(res,i-d.shift())
      }
      // 如果当前点(i) <= d的最后一个点(有可能是上一个点)
      // 那么说明，当前点是一个0或者负值，是绝对不能做为开始点去算和的
      // 因此当前点需要pop掉
      // 循环检查
      while(d.length>0 &amp;&amp; sum[i]<=sum[d[d.length-1]]){
        d.pop()
      }
      // 每一个点都先放入d，后续会检查这些点是否能作为计算和的开始点
      d.push(i)
    }
  return res<=N ? res : -1
};
```

