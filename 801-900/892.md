### 892. 三维形体的表面积

难度：Easy

相关话题：`几何`、`数学`

在 `N*N` 的网格上，我们放置一些 `1 * 1 * 1` 的立方体。



每个值 `v = grid[i][j]` 表示 `v` 个正方体叠放在单元格 `(i, j)` 上。



返回最终形体的表面积。













 **示例 1：** 





```
输入：

[[2]]
输出：

10

```

 **示例 2：** 





```
输入：

[[1,2],[3,4]]
输出：

34

```

 **示例 3：** 





```
输入：

[[1,0],[0,2]]
输出：

16

```

 **示例 4：** 





```
输入：

[[1,1,1],[1,0,1],[1,1,1]]
输出：

32

```

 **示例5：** 





```
输入：

[[2,2,2],[2,1,2],[2,2,2]]
输出：

46

```





 **提示：** 





*  `1 &lt;= N &lt;= 50` 

*  `0 &lt;= grid[i][j] &lt;= 50` 






-----

思路：

常规办法就是对每一个位置的`上下左右`4个方向进行分析，分别求出当前位置的4个边还能剩多少未被覆盖的，再加上`顶上的面`和`底下的面`。

比较更好的办法对每一个位置，只需要求`上左`2个方向即可，即使当前的位置可能多了或者少了，但整个连续体的结果是正确的。

你可以想象前面有一个楼梯，假设这个楼梯就是三维方格摆放图，你能看到暴露的面，就是`最高一层楼梯的高度*楼梯的宽度`。


```
/**
 * @param {number[][]} grid
 * @return {number}
 */
var surfaceArea = function(grid) {
  let sum=0
  for(let i=0;i&lt;grid.length;i++){
    for(let j=0;j&lt;grid[i].length;j++){
      let cur=grid[i][j]
      let prevL=0,prevT=0
      if(j&gt;0)prevL=grid[i][j-1]
      if(i&gt;0)prevT=grid[i-1][j]
      let overlap=Math.min(cur,prevL)*2+Math.min(cur,prevT)*2
      let curNum=cur*6-(cur-1&gt;0?cur-1:0)*2-overlap
      sum+=curNum
    }
  }
  return sum
};



```
