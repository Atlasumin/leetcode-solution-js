### 828. 独特字符串

难度：Hard

相关话题：`双指针`

如果一个字符在字符串 `S` 中有且仅有出现一次，那么我们称其为独特字符。



例如，在字符串 `S = "LETTER"` 中， `"L"` 和 `"R"` 可以被称为独特字符。



我们再定义 `UNIQ(S)` 作为字符串 `S` 中独特字符的个数。



那么，在 `S = "LETTER"` 中， `UNIQ("LETTER") = 2` 。



对于给定字符串 `S` ，计算其所有非空子串的独特字符的个数（即 `UNIQ(substring)` ）之和。



如果在  `S` 的不同位置上出现两个甚至多个相同的子串，那么我们认为这些子串是不同的。



考虑到答案可能会非常大，规定返回格式为：结果 mod `10 ^ 9 + 7` 。







**示例 1:** 



```
输入:"ABC"
输出:10
解释: 所有可能的子串为："A","B","C","AB","BC" 和 "ABC"。
     其中，每一个子串都由独特字符构成。
     所以其长度总和为：1 + 1 + 1 + 2 + 2 + 3 = 10
```


**示例 2:** 



```
输入:"ABA"
输出:8
解释:除了子串 UNIQ(&#39;ABA&#39;) = 1，其余与示例1相同。
```






**说明:**   `0 <= S.length <= 10000` 。




-----

思路：

我们使用一个`idxes`保存每个字母的前2个索引，为什么要前2个索引呢？

例如：

```
A B C A B C A
0 1 2 3 4 5 6
```

在最后一个(索引为6)的`A`时，它的前两个索引分别是`0`和`3`，写成`[0,3]`，那么当检查它的子数组时，
我们首先将最理想的状态，即每个子数组都增加`1`，因此`+7`，因为带有索引`6`的子数组有`7`个。

再看：

* 从索引`6`到`3`之间这3个数，`A`是没有重复值的，每个子数组可以增加`1`个独特字符，因此不变(因为之前`+7`包括了)。

* 从索引`3`到`0`之间这3个数，`A`有了重复值，每个子数组要减少`n`个独特字符，这`n`是多少呢？

    因为在上一次，即索引`5`时，那时候从索引`3`到`0`之间这3个数，`A`是没有重复值，他们的独特字符都增加`1`。
    
    而这次(索引`6`)，这几个数突然有了重复值，那么他们的独特字符则需要`-1`，因为我们之间`+7`里面这里每个相当于`+1`，
    因此最终需要`-2`。
    
* 从索引`0`之前，`A`在之前就已经有了重复值，再来一个重复值也没有影响，因此这之前的不需要变化，但我们之前`+7`的时候，
    里面每个值都`+1`，因此这里需要`-1`。
    

因此递推公式为`dp[i]=dp[i-1]+(dp[i-1]-dp[i-2])+(i+1)-(idxes[code][1]-idxes[code][0])*2-(idxes[code][0]-(-1))`

这里`dp[i-1]-dp[i-2]`指的是上一次的独特字符增加的数量；

`i+1`指这一次独特字符最理想的增加数量；

`(idxes[code][1]-idxes[code][0])*2`即上面介绍的第一阶段需要减去的。

`(idxes[code][0]-(-1))`即上面介绍第二阶段需要减去的。

最后我们需要更新`idex`，只需要保存最近的2个索引。

```
/**
 * @param {string} S
 * @return {number}
 */
var uniqueLetterString = function(S) {
  if(S==='')return 0
  let MOD=1e9+7,
      idxes=Array(26).fill().map(()=>[-1,-1]),
      dp=Array(S.length).fill(0)
  dp[0]=1
  idxes[S.charCodeAt(0)-65]=[-1,0]
  for(let i=1;i<S.length;i++){
    let code=S.charCodeAt(i)-65
    
    dp[i]=(dp[i-1]+(dp[i-1]-(dp[i-2]||0))+(i+1)-(idxes[code][1]-idxes[code][0])*2-(idxes[code][0]-(-1))) % MOD
     updateIdxes(i,code)

  }
  return dp[dp.length-1]
  
  function updateIdxes(i,code){
    let t=idxes[code][1]
    idxes[code][1]=i
    idxes[code][0]=t    
  }
};
```

